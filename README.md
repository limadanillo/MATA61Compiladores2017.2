# MATA61Compiladores2017.2
Objetivo O objetivo deste projeto é adquirir experiência na implementação de linguagens de programação através da construção de um compilador para uma simples linguagem procedimental chamada Def. Avaliação 10%  Analisador Léxico 30%  Analisador Sintático/Semântico 60%  Gerador de Código A Linguagem Program     = (DecVar | DecFunc)*  DecVar      = let ID ('=' Expr)? ';'  DecFunc     = def ID '(' ParamList? ')' Block ParamList   = ID (',' ID)*  Block       = '{' DecVar* Stmt* '}'  Stmt        = Assign ';' |               FuncCall ';' |               if '(' Expr ')' Block (else Block)? |               while '(' Expr ')' Block |               return Expr? ';' |               break ';' |               continue ';'  Assign      = ID '=' Expr FuncCall    = ID '(' ArgList? ')' ArgList     = Expr (',' Expr)*  Expr        = Expr BinOp Expr |               UnOp Expr |               '(' Expr ')' |               FuncCall |               DEC |               ID  BinOp       = '+' | '-' | '*' | '/' | '&lt;' | '&lt;=' |               '>' | '>=' | '==' | '!=' | '&amp;&amp;' | '||' UnOp        = '-'  | '!' Embora não estejam refletidas explicitamente na gramática, todas as operações binárias na linguagem são associativas à esquerda e a precedência dos operadores é a mesma usada na linguagem C. Mais precisamente, há sete níveis de precedência dos operadores, listados abaixo do maior nível para a menor nível de precedência. Operadores    Comentarios -             Negaçāo unária             --> maior precedência !             Negaçāo lógica unária (NOT) * /           Multiplicaçāo e divisāo (inteiros) + -           Adiçāo e subtraçāo (inteiros) &lt; &lt;= >= >     Relaçāo lógica == !=         Igualdade e desigualdade lógicas &amp;&amp;            Conjunçāo lógica (AND) ||            Disjunçāo lógica (OR)      --> menor precedência Importante notar que da forma como a  gramática está descrita acima, ela não é nem LL (1) nem LR (1). Contudo, a gramática deve ser transformada (pelas técnicas vistas em sala de aula) para que seja possível a construção mais adequada do analisador sintático para a linguagem.  Exemplo // add.def - simple addition example def add(x, y) {   return x + y; // add the two parameters } def main() {   let a;   a = 3;   print(add(a, 2)); } O resultado correto da execuçāo do código acima é o valor decimal 5, onde a função de entrada é definida pela função main.  Considerações Léxicas Há quatro classes de tokens na linguagem: ID      Identificador DEC     Literal decimal (inteiro) KEY     Palavra-chave SYM     Símbolos léxicos ERROR   Lexema do primeiro erro encontrado Os identificadores e palavras-chave devem começar com um caractere alfabético e podem conter caracteres alfanuméricos e o caractere de sublinhado '_'.  Uma palavra-chave pode ser vista como um identificador especial que é reservado e nao pode ser usado para definir nomes de variáveis ou funções. As palavras-chave e os identificadores são sensíveis a maiúsculas e minúsculas, e todas as palavras-chave são representadas por minúsculas. Por exemplo, if é uma palavra-chave, mas IF pode ser um nome de variável; foo e Foo são dois exemplos de nomes diferentes na linguagem, podendo referir-se a duas variáveis distintas. Note que palavras-chave e identificadores devem ser separados por espaço em branco, ou por algum token que não é nem uma palavra-chave nem um identificador. Por exemplo, ifbreak é um único identificador, e não duas palavras-chave distintas. Se uma sequência de caracteres começa com um caractere alfabético, então ele deve representar a sequência mais longa de caracteres alfanuméricos e sublinhados, formando um único token (palavra-chave ou identificador). Os símbolos podem ser divididos em três tipos: 1) operadores de agrupamento: parênteses, chaves, colchetes, atribuição (sinal de igual), vírgulas e ponto-e-vírgula, 2) operadores binários (BINOP) e 3) operadores unários (UNOP). Há uma variedade de operadores binários e unários na linguagem, incluindo tanto os operadores aritméticos (por exemplo, mais e menos) e operadores lógicos/relacionais (por exemplo, ou/e booleano e menor-que). Abaixo está a lista de todos os símbolos léxicos da linguagem: (  {  }  )  ,  ;  =  +  -  *  /  &lt;  >  &lt;=  >=  ==  !=  &amp;&amp;  ||  ! As seguintes palavras-chave são reservadas na linguagem:  let  def  if  else  while  return  break  continue Os comentários devem ser iniciados por "//" e vão até o final da linha. Um token especial "Whitespace" pode aparecer entre quaisquer tokens, e consiste em um ou mais espaços em branco, tabs (\t), e quebra de linhas (\n). Comentários e espaços em branco devem ser descartados durante a fase de análise léxica do compilador. Nota: deve-se imprimir também o número da linha onde foi encontrado o token, incluindo o token de erro. O analisador léxico deve parar após encontrar o primeiro erro léxico. Semântica Um programa escrito na linguagem consiste em definições de variáveis e funções, respeitando escopos léxicos correspondentes. Variáveis A linguagem permite somente o uso de um tipo de variável: inteiro com sinal (32-bit). Variáveis, consideradas globais, podem ser declaradas fora de funções e são visíveis por todo código. Variáveis declaradas dentro de funções ou blocos, consideradas locais, somente são visíveis dentro daquela função ou bloco (escopo léxico). Se uma variável for referenciada antes de uma atribuição, considera-se que a variável foi inicializada com valor zero (0).  Funções Funções podem não retornar explicitamente valor algum ou retornam um único valor, mas podem receber um número ilimitado de argumentos. Todo código escrito  na linguagem deve conter uma função chamada main (sem argumentos) que representa o início da execução do programa. Para as funções que não retornam valores explicitamente através da construção return, assume-se o valor zero (0) como retorno. Em uma chamada de função, o número de parâmetros passados (reais) deve ser igual ao número de parâmetros declarados (formais) da função. Escopo léxico Há dois escopos válidos em um programa: global e local. O escopo global consiste em nomes de funções e variáveis declaradas fora de funções. O escopo local consiste em nomes de variáveis e parâmetros formais declarados em uma função. Escopos locais adicionais podem existem dentro de cada bloco no código, como após as construções if ou while, ou em qualquer parte do código onde há um novo bloco. Nenhum nome de identificador ou função pode ser definido mais de uma vez no mesmo escopo. Assim, nomes de variáveis e funções devem ser distintos no escopo global, e nomes de variáveis locais e nomes de parâmetros formais devem ser distintos em cada escopo local. Variáveis ou funções devem ser declaradas antes de serem usadas naquele escopo/bloco. Entrada/Saída A linguagem prevê a função  print '(' Expr ')'  que não é definida na gramática da linguagem, e sim parte do ambiente de execução da linguagem. A função exibe o valor avaliado de uma expressão na saída padrão seguido de uma quebra de linha (\n). Para isso, será usada uma syscall no MIPS (detalhes na seçāo abaixo).  Notas sobre Implementaçāo O compilador implementado deve gerar código correto (não necessariamente otimizado) para o processador MIPS (32 bits); detalhes da arquitetura MIPS aqui e do conjunto de instruções aqui.  Requisitos da Implementaçāo: Deve ser implementado em C/C++ Deve rodar no ambiente Linux/Unix Pode opcionalmente usar ferramentas automáticas (Lex/Flex &amp; Yacc/Bison) O programa do compilador deve receber dois parâmetros/argumentos (argv). O primeiro argumento será o arquivo do código fonte como entrada (e.g., add.def) e o segundo argumento será o arquivo de saída (e.g., out.asm) onde será gravado o código em assembly MIPS; por exemplo: $ ./compilador add.def out.asm Para executar e avaliar os resultados gerados pelos programas da linguagem alvo (MIPS assembly) iremos usar o simulador SPIM (detalhes no manual aqui).  O SPIM (MIPS32 Simulator) pode ser baixado aqui. Se você usa Ubuntu Linux, pode instalar o SPIM pelo comando "sudo apt-get install spim". Veja aqui detalhes das system calls disponíveis no simulador SPIM. Para saber mais sobre geradores automáticos de analisadores léxico e sintático, leia os seguintes ponteiros: Flex in a Nutshell  e Introduction to Bison. Formato de Arquivos Analisador Léxico Como executar (dois parametros: entrada e saída) $ ./lexico add.def out.lex Exemplo de Arquivo de Entrada: def main() {   let a;   a = 4 + 5;   return a; } Exemplo de Arquivo de Saída (quaisquer espaços em branco serão ignorados): KEY "def" 1 ID "main" 1 SYM "(" 1 SYM ")" 1 SYM "{" 2 KEY "let" 3 ID "a" 3 SYM ";" 3 ID "a" 4 SYM "=" 4 DEC "4" 4 SYM "+" 4 DEC "5" 4 SYM ";" 4 KEY "return" 5 ID "a" 5 SYM ";" 5 SYM "}" 6 Analisador Sintático Como executar (dois parametros: entrada e saída) $ ./lexico add.def out.syn Há várias possíveis árvores corretas que podem ser geradas para uma entrada de um programa. Assim, é importante ter um formato único para representação da árvore sintática (abstrata) que contenha um número mínimo de elementos/nós e seja independente de qualquer implementação específica. A saída deve estar na notação estilo LISP: [operador [operando_1] ... [operando_N]] Recursivamente, cada operando pode ser definido por um outro operador; por exemplo, [op_1 [op_2 [a] [b]] [c]] onde "op_1" possui dois operandos: "[op_2 [a] [b]]" e "[c]", e operador "op_2" possui dois operandos: "[a]" e "[b]".  Em caso de erro sintático ou semântico,  o conteúdo do arquivo de saída deve ser vazio.  Além dos operadores (como +, -,  /) que estão presentes como nós da AST, temos abaixo a lista dos elementos/nós que devem ser usados para criar a AST: program, decvar, decfunc, paramlist, block, assign, if, return, continue, break, while, funccall, arglist Exemplo de Arquivo de Entrada: def add(x, y) {     return x + y; }  def main() {     let a;     a = 3;     return add(a, 2); } Exemplo de Arquivo de Saída (AST em "labelled bracket notation") [program    [decfunc      [add]      [paramlist [x] [y]]      [block        [return          [+ [x] [y]]       ]     ]   ]     [decfunc      [main]      [paramlist ]      [block       [decvar [a]]        [assign [a] [3]]       [return         [funccall            [add]           [arglist [a] [2]]         ]          ]      ]   ] ]  
